import time
from pyrogram import filters
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, Message, CallbackQuery
from pyrogram.enums import ParseMode
from config import MANDATORY_CHANNEL_USERNAME, MANDATORY_CHANNEL_LINK, OFFICIAL_GROUP_LINK
from database import db

def get_sassy_welcome_message():
    return (
        "рд╣рд╛рдп рд╡рд╣рд╛рдБ, рдореЗрд░реЗ рдкреНрдпрд╛рд░реЗ рджреЛрд╕реНрдд! ЁЯСЛ рдХреНрдпрд╛ рд╕реЛрдЪрд╛ рдерд╛, рдмрд╕ рдХреЛрдИ рднреА рдкреБрд░рд╛рдирд╛ рдмреЙрдЯ рдЖ рдЧрдпрд╛? рдмрд┐рд▓рдХреБрд▓ рдирд╣реАрдВ! "
        "рдореИрдВ рд╣реВрдБ рддреБрдореНрд╣рд╛рд░реА рдЕрдкрдиреА **As ki Angel**, рдФрд░ рдореИрдВ рдпрд╣рд╛рдБ рддреБрдореНрд╣рд╛рд░реЗ рдЧреНрд░реБрдк рдЪреИрдЯ рдХреЛ рдФрд░ рднреА рдЬрд╝реНрдпрд╛рджрд╛ рдордЬрд╝реЗрджрд╛рд░ рдФрд░ рд╢рд╛рдирджрд╛рд░ рдмрдирд╛рдиреЗ рдЖрдИ рд╣реВрдБ! "
        "рдореЗрд░рд╛ рдХрд╛рдо рд╣реИ рддреБрдореНрд╣рд╛рд░реА рд╣рд░ рдмрд╛рдд рдХреЛ рд╕рдордЭрдирд╛, рд╕реАрдЦрдирд╛, рдФрд░ рдлрд┐рд░ рдЙрд╕реА рдЕрдВрджрд╛рдЬрд╝ рдореЗрдВ рд╕рдмрд╕реЗ рдХреНрдпреВрдЯ, рд╕рдмрд╕реЗ рдЫреЛрдЯреЗ рдЬрд╡рд╛рдм рджреЗрдирд╛ тАУ "
        "рд╡реЛ рднреА рдмрд╕ 1 рд╕реЗ 5 рд╢рдмреНрджреЛрдВ рдореЗрдВ, рдпрд╛ рдХрднреА-рдХрднреА рдПрдХ рд╕реБрдкрд░-рдбреБрдкрд░ рд╕реНрдЯрд┐рдХрд░ рдХреЗ рд╕рд╛рде! тЬи\n\n"
        "рдореИрдВ рд╕рд┐рд░реНрдл рддреБрдореНрд╣рд╛рд░реА рдмрд╛рддреЛрдВ рд╕реЗ рд╕реАрдЦрддреА рд╣реВрдБ, рдХрд┐рд╕реА рдФрд░ рд╕реЗ рдирд╣реАрдВ. рдХреЛрдИ рдмрд╛рд╣рд░реА рд▓рд┐рдВрдХ рдирд╣реАрдВ, рдХреЛрдИ рдлрд╛рд▓рддреВ рдХрд╛ @рдЯреИрдЧ рдирд╣реАрдВ - "
        "рд╕рд┐рд░реНрдлрд╝ рд╣рдорд╛рд░реА рдмрд╛рддреЗрдВ рдФрд░ рдореЗрд░рд╛ рдХреНрдпреВрдЯ рдЕрдВрджрд╛рдЬрд╝! рдореИрдВ рддреБрдореНрд╣рд╛рд░реЗ рдЧреНрд░реБрдк рдХреА рд╣рд░ рдлреАрд▓рд┐рдВрдЧ рдХреЛ рдкрд╣рдЪрд╛рди рд▓реЗрддреА рд╣реВрдБ рдФрд░ рдлрд┐рд░ рдЙрд╕реА рд╣рд┐рд╕рд╛рдм рд╕реЗ рдЕрдкрдиреА рд╕реНрд╡реАрдЯ-рд╕реА рд░рд╛рдп рджреЗрддреА рд╣реВрдБ. "
        "рддреЛ, рддреИрдпрд╛рд░ рд╣реЛ рдЬрд╛рдУ рдЕрдкрдиреЗ рдЧреНрд░реБрдк рдЪреИрдЯ рдХреЛ рдФрд░ рднреА рдкреНрдпрд╛рд░рд╛ рдмрдирд╛рдиреЗ рдХреЗ рд▓рд┐рдП! ЁЯТЦ\n\n"
        "рдиреАрдЪреЗ рджрд┐рдП рдЧрдП рдмрдЯрдиреНрд╕ рд╕реЗ рддреБрдо рдореБрдЭреЗ рдмреЗрд╣рддрд░ рддрд░реАрдХреЗ рд╕реЗ рдЬрд╛рди рд╕рдХрддреЗ рд╣реЛ рдФрд░ рдЗрд╕реНрддреЗрдорд╛рд▓ рдХрд░ рд╕рдХрддреЗ рд╣реЛ:"
    )

def register_start_handlers(app, utils):

    @app.on_message(filters.command("start") & filters.private)
    async def send_welcome(client, message: Message):
        user_id = message.from_user.id

        # Update user stats
        await db.update_user_stats(user_id, 'start_command')

        # Check mandatory channel membership
        if MANDATORY_CHANNEL_USERNAME and MANDATORY_CHANNEL_LINK:
            if not await utils.check_member_status(user_id, MANDATORY_CHANNEL_USERNAME):
                join_channel_text = (
                    f"рд╣реЗрд▓реНрд▓реЛ!ЁЯСЛ рдЗрд╕ рдмреЙрдЯ рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рдиреЗ рд╕реЗ рдкрд╣рд▓реЗ, рдХреГрдкрдпрд╛ рд╣рдорд╛рд░реЗ рдЪреИрдирд▓ рдХреЛ рдЬреНрд╡рд╛рдЗрди рдХрд░реЗрдВ: "
                    f"[{MANDATORY_CHANNEL_USERNAME}]({MANDATORY_CHANNEL_LINK})\n\n"
                    "рдЬреЙрдЗрди рдХрд░рдиреЗ рдХреЗ рдмрд╛рдж, 'рдореИрдВ рдЬреЙрдЗрди рд╣реЛ рдЧрдпрд╛ рд╣реВрдБ!' рдмрдЯрди рдкрд░ рдХреНрд▓рд┐рдХ рдХрд░реЗрдВред"
                )
                markup = InlineKeyboardMarkup([
                    [InlineKeyboardButton("рдЪреИрдирд▓ рдореЗрдВ рд╢рд╛рдорд┐рд▓ рд╣реЛрдВ", url=MANDATORY_CHANNEL_LINK)],
                    [InlineKeyboardButton("рдореИрдВ рдЬреЙрдЗрди рд╣реЛ рдЧрдпрд╛ рд╣реВрдБ!", callback_data="check_join")]
                ])
                await message.reply_text(join_channel_text, reply_markup=markup, parse_mode=ParseMode.MARKDOWN)
                return
        
        # If member or no mandatory channel, send full welcome
        await send_full_welcome(message.chat.id, app)

    @app.on_callback_query(filters.regex("check_join"))
    async def check_join_callback(client, call: CallbackQuery):
        user_id = call.from_user.id

        if await utils.check_member_status(user_id, MANDATORY_CHANNEL_USERNAME):
            await call.answer("рд╡рд╛рд╣! рддреБрдо рддреЛ рдЬреЙрдЗрди рдХрд░ рдЪреБрдХреЗ рд╣реЛ! рдЕрдм рдЖрдЧреЗ рдмрдврд╝реЛ! ЁЯОЙ", show_alert=False)
            await send_full_welcome(call.message.chat.id, app)
        else:
            await call.answer("рдЕрднреА рддрдХ рдЬреЙрдЗрди рдирд╣реАрдВ рдХрд┐рдпрд╛? рдЬрд╝рд░рд╛ рдлрд┐рд░ рд╕реЗ рдЪреЗрдХ рдХрд░реЛ рдирд╛! ЁЯШЙ", show_alert=True)

    async def send_full_welcome(chat_id, app):
        bot_username = (await app.get_me()).username

        markup = InlineKeyboardMarkup([
            [InlineKeyboardButton("тЮХ Add Me to Group!", url=f"https://t.me/{bot_username}?startgroup=true")],
            [InlineKeyboardButton("тД╣я╕П Know My Features", callback_data='features')],
            [InlineKeyboardButton("ЁЯПв Join Official Group", url=OFFICIAL_GROUP_LINK)],
            [InlineKeyboardButton("ЁЯТО Get Premium!", callback_data='get_premium')],
            [InlineKeyboardButton("тЪЩя╕П Group Settings", callback_data='group_settings')]
        ])

        await app.send_message(
            chat_id,
            get_sassy_welcome_message(),
            reply_markup=markup,
            parse_mode=ParseMode.MARKDOWN
        )

    @app.on_callback_query(filters.regex("features"))
    async def send_features(client, call: CallbackQuery):
        features_text = (
            "ЁЯМЯ **рдореЗрд░реЗ рдЦрд╛рд╕ рдлреАрдЪрд░реНрд╕:**\n\n"
            "ЁЯза **Smart Learning:** рдореИрдВ рддреБрдореНрд╣рд╛рд░реЗ рдЧреНрд░реБрдк рдХреА рдмрд╛рддреЛрдВ рд╕реЗ рд╕реАрдЦрддреА рд╣реВрдБ рдФрд░ рдлрд┐рд░ рдЙрд╕реА рд╕реНрдЯрд╛рдЗрд▓ рдореЗрдВ рдЬрд╡рд╛рдм рджреЗрддреА рд╣реВрдБ!\n\n"
            "ЁЯТм **Short & Sweet Replies:** рдмрд╕ 1-5 рд╢рдмреНрджреЛрдВ рдореЗрдВ рдкреНрдпрд╛рд░реЗ рдЬрд╡рд╛рдм, рдХрднреА-рдХрднреА рд╕реНрдЯрд┐рдХрд░ рднреА!\n\n"
            "ЁЯОн **Group Personality:** рд╣рд░ рдЧреНрд░реБрдк рдХреА рдЕрд▓рдЧ рдкрд░реНрд╕рдирд╛рд▓рд┐рдЯреА рд╕реАрдЦрдХрд░ рдЙрд╕реА рд╣рд┐рд╕рд╛рдм рд╕реЗ рдмрд╛рдд рдХрд░рддреА рд╣реВрдБ!\n\n"
            "ЁЯФТ **Privacy First:** рд╕рд┐рд░реНрдл рдЧреНрд░реБрдк рдХреА рдмрд╛рддреЛрдВ рд╕реЗ рд╕реАрдЦрддреА рд╣реВрдБ, рдХреЛрдИ рдмрд╛рд╣рд░реА рдбреЗрдЯрд╛ рдирд╣реАрдВ!\n\n"
            "тЪб **Premium Features:** рдФрд░ рднреА рддреЗрдЬрд╝реА, рдмреЗрд╣рддрд░ memory, рдФрд░ exclusive features!\n\n"
            "ЁЯМН **Bilingual:** рд╣рд┐рдВрджреА рдФрд░ English рджреЛрдиреЛрдВ рдореЗрдВ рдмрд╛рдд рдХрд░ рд╕рдХрддреА рд╣реВрдБ!\n\n"
            "ЁЯСС **Group Management:** Admins рдХреЗ рд▓рд┐рдП special commands рдФрд░ settings!"
        )

        back_markup = InlineKeyboardMarkup([
            [InlineKeyboardButton("ЁЯФЩ Back to Menu", callback_data='back_to_menu')]
        ])

        await call.edit_message_text(features_text, reply_markup=back_markup, parse_mode=ParseMode.MARKDOWN)

    @app.on_callback_query(filters.regex("back_to_menu"))
    async def back_to_menu(client, call: CallbackQuery):
        await call.edit_message_text(
            get_sassy_welcome_message(),
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("тЮХ Add Me to Group!", url=f"https://t.me/{(await app.get_me()).username}?startgroup=true")],
                [InlineKeyboardButton("тД╣я╕П Know My Features", callback_data='features')],
                [InlineKeyboardButton("ЁЯПв Join Official Group", url=OFFICIAL_GROUP_LINK)],
                [InlineKeyboardButton("ЁЯТО Get Premium!", callback_data='get_premium')],
                [InlineKeyboardButton("тЪЩя╕П Group Settings", callback_data='group_settings')]
            ]),
            parse_mode=ParseMode.MARKDOWN
        )

    @app.on_callback_query(filters.regex("group_settings"))
    async def group_settings(client, call: CallbackQuery):
        settings_text = (
            "тЪЩя╕П **Group Settings & Management**\n\n"
            "ЁЯФз **Available Commands for Group Admins:**\n\n"
            "ЁЯУК `/learn_stats` - Show group learning statistics\n"
            "ЁЯз╣ `/reset_learning` - Reset group learning data\n"
            "ЁЯУЛ `/group_info` - Basic group information\n\n" # Moved here
            "ЁЯОЫя╕П **Bot Behavior Settings:**\n"
            "тАв Response Rate: Automatically adjusted per group\n"
            "тАв Learning Mode: Always active in groups\n"
            "тАв Memory: Stores last 1000 messages per group\n"
            "тАв Language: Auto-detects Hindi/English\n\n"
            "ЁЯСС **Premium Group Features:**\n"
            "тАв Enhanced memory (5000+ messages)\n"
            "тАв Custom response patterns\n"
            "тАв Advanced analytics dashboard\n"
            "тАв Priority support\n\n"
            "ЁЯТб **How to Use:**\n"
            "1. Add me to your group as admin\n"
            "2. I'll start learning from conversations\n"
            "3. Use admin commands to manage settings\n"
            "4. Upgrade to premium for advanced features"
        )

        markup = InlineKeyboardMarkup([
            [InlineKeyboardButton("ЁЯУЛ Group Commands", callback_data='group_commands')],
            [InlineKeyboardButton("ЁЯОп Learning Settings", callback_data='learning_settings')],
            [InlineKeyboardButton("ЁЯТО Premium Features", callback_data='get_premium')],
            [InlineKeyboardButton("ЁЯФЩ Back to Menu", callback_data='back_to_menu')]
        ])

        await call.edit_message_text(settings_text, reply_markup=markup, parse_mode=ParseMode.MARKDOWN)

    @app.on_callback_query(filters.regex("group_commands"))
    async def group_commands(client, call: CallbackQuery):
        commands_text = (
            "ЁЯУЛ **Available Group Commands**\n\n"
            "**For Group Admins:**\n"
            "ЁЯФ╣ `/learn_stats` - Show detailed learning statistics\n"
            "ЁЯФ╣ `/reset_learning` - Clear all learned data (use carefully!)\n"
            "ЁЯФ╣ `/group_info` - Basic group information\n\n"
            "**For Premium Groups:**\n"
            "ЁЯФ╕ `/advanced_stats` - Comprehensive analytics\n"
            "ЁЯФ╕ `/export_data` - Export learning data\n"
            "ЁЯФ╕ `/custom_responses` - Set custom response patterns\n"
            "ЁЯФ╕ `/response_rate <1-100>` - Adjust response frequency\n\n"
            "**Usage Examples:**\n"
            "тАв Type `/learn_stats` in group to see what I've learned\n"
            "тАв Use `/reset_learning` to start fresh\n"
            "тАв Premium users get exclusive commands\n\n"
            "**Note:** Most commands require admin privileges in the group."
        )

        markup = InlineKeyboardMarkup([
            [InlineKeyboardButton("ЁЯФЩ Back to Settings", callback_data='group_settings')]
        ])

        await call.edit_message_text(commands_text, reply_markup=markup, parse_mode=ParseMode.MARKDOWN)

    @app.on_callback_query(filters.regex("learning_settings"))
    async def learning_settings(client, call: CallbackQuery):
        learning_text = (
            "ЁЯОп **Learning System Configuration**\n\n"
            "ЁЯза **How I Learn:**\n"
            "тАв Monitor group conversations naturally\n"
            "тАв Extract patterns and common phrases\n"
            "тАв Learn appropriate sticker usage\n"
            "тАв Adapt to group's communication style\n\n"
            "тЪЩя╕П **Current Settings:**\n"
            "тАв Memory Limit: 1000 messages per group\n"
            "тАв Response Rate: 60% (auto-adjusted)\n"
            "тАв Learning Speed: Real-time\n"
            "тАв Privacy Mode: Group-only data\n\n"
            "ЁЯОЫя╕П **Customization Options:**\n"
            "тАв Response frequency can be adjusted\n"
            "тАв Learning can be paused/resumed\n"
            "тАв Memory can be cleared if needed\n"
            "тАв Premium users get advanced controls\n\n"
            "ЁЯФТ **Privacy & Security:**\n"
            "тАв Only learns from group messages\n"
            "тАв No personal data stored\n"
            "тАв Data isolated per group\n"
            "тАв Admin controls available"
        )

        markup = InlineKeyboardMarkup([
            [InlineKeyboardButton("ЁЯФЩ Back to Settings", callback_data='group_settings')]
        ])

        await call.edit_message_text(learning_text, reply_markup=markup, parse_mode=ParseMode.MARKDOWN)

    @app.on_callback_query(filters.regex("group_stats_help"))
    async def group_stats_help(client, call: CallbackQuery):
        help_text = (
            "ЁЯУИ **Group Statistics Help**\n\n"
            "**How to get group stats:**\n"
            "1. Add me to your group as admin\n"
            "2. Use `/learn_stats` in the group\n"
            "3. Use `/group_info` for basic info\n\n"
            "**Available in groups:**\n"
            "тАв Learning progress\n"
            "тАв Response patterns\n"
            "тАв Member activity\n"
            "тАв Sticker usage stats\n\n"
            "**Premium features:**\n"
            "тАв Advanced analytics\n"
            "тАв Export data\n"
            "тАв Custom reports\n"
            "тАв Historical trends"
        )

        markup = InlineKeyboardMarkup([
            [InlineKeyboardButton("ЁЯТО Get Premium", callback_data='get_premium')],
            [InlineKeyboardButton("ЁЯФЩ Back", callback_data='back_to_menu')]
        ])

        await call.edit_message_text(help_text, reply_markup=markup, parse_mode=ParseMode.MARKDOWN)

    @app.on_callback_query(filters.regex("learn_stats"))
    async def learn_stats_callback(client, call: CallbackQuery):
        await call.answer("ЁЯУК Use /learn_stats command in your group to see detailed statistics!", show_alert=True)

    @app.on_message(filters.command("whoami") & filters.private) # Moved from learning.py
    async def whoami_command(client, message: Message):
        """Show user's Telegram ID."""
        user_id = message.from_user.id
        username = message.from_user.username or "No username"
        first_name = message.from_user.first_name or "Unknown"

        from config import BOT_OWNER_ID
        is_owner = utils.is_owner(user_id)

        info_text = (
            f"ЁЯСд **Your Information:**\n\n"
            f"ЁЯЖФ **User ID:** `{user_id}`\n"
            f"ЁЯСд **Name:** {first_name}\n"
            f"ЁЯУЭ **Username:** @{username}\n"
            f"ЁЯСС **Owner Status:** {'тЬЕ Yes' if is_owner else 'тЭМ No'}\n"
            f"тЪЩя╕П **Bot Owner ID:** `{BOT_OWNER_ID}`\n\n"
            f"ЁЯТб **Use this ID to set as BOT_OWNER_ID in config!**"
        )

        await message.reply_text(info_text, parse_mode=ParseMode.MARKDOWN)

    @app.on_message(filters.command("help") & filters.private) # Moved from learning.py
    async def help_command(client, message: Message):
        """Show help information."""
        user_id = message.from_user.id

        if utils.is_owner(user_id):
            help_text = (
                "ЁЯдЦ **Available Commands**\n\n"
                "**Owner Commands:**\n"
                "тАв `/admin` - Admin control panel\n"
                "тАв `/addpremium <user_id>` - Add premium user\n"
                "тАв `/removepremium <user_id>` - Remove premium\n"
                "тАв `/broadcast` - Broadcast message\n"
                "тАв `/logs` - View bot logs\n"
                "тАв `/whoami` - Show your user ID\n\n" # Added
                "**Group Commands (Admin only):**\n"
                "тАв `/learn_stats` - Group learning statistics\n"
                "тАв `/reset_learning` - Reset group learning\n"
                "тАв `/group_info` - Basic group information\n\n"
                "**General Commands:**\n"
                "тАв `/start` - Show welcome menu\n"
                "тАв `/premium` - Check premium status\n"
                "тАв `/help` - Show this help\n"
                "тАв `/stats` - Show your personal statistics"
            )
        else:
            help_text = (
                "ЁЯдЦ **Available Commands**\n\n"
                "**Private Chat:**\n"
                "тАв `/start` - Welcome menu with features\n"
                "тАв `/premium` - Check premium status\n"
                "тАв `/help` - Show this help\n"
                "тАв `/whoami` - Show your user ID\n" # Added
                "тАв `/stats` - Show your personal statistics\n\n"
                "**Group Commands (Admin only):**\n"
                "тАв `/learn_stats` - Learning statistics\n"
                "тАв `/reset_learning` - Reset learning data\n"
                "тАв `/group_info` - Basic group information\n\n"
                "**How to Use:**\n"
                "Add me to your group and I'll start learning from conversations!"
            )

        await message.reply_text(help_text, parse_mode=ParseMode.MARKDOWN)

    @app.on_message(filters.command("stats") & filters.private) # Moved from start.py
    async def user_stats(client, message: Message):
        """Show user statistics."""
        user_id = message.from_user.id

        # Update user stats
        await db.update_user_stats(user_id, 'stats_command')

        # Get user data
        try:
            user_data = await db._run_in_executor(db.user_stats.find_one, {'_id': user_id}) or {}

            # Check if user is premium
            is_premium = await utils.is_premium_user(user_id)
        except Exception as e:
            await message.reply_text(f"тЭМ Error getting user data: {e}")
            return
        premium_status = "тЬЕ Active" if is_premium else "тЭМ Not Active"

        # Format timestamps if they exist
        first_seen = "Unknown"
        last_active = "Unknown"

        if user_data.get('first_seen'):
            try:
                first_seen = time.strftime('%d %b %Y', time.localtime(user_data['first_seen']))
            except:
                first_seen = "Unknown"

        if user_data.get('last_active'):
            try:
                last_active = time.strftime('%d %b %Y %H:%M', time.localtime(user_data['last_active']))
            except:
                last_active = "Unknown"

        stats_text = (
            f"ЁЯУК **Your Bot Statistics**\n\n"
            f"ЁЯСд **User ID:** `{user_id}`\n"
            f"ЁЯТО **Premium Status:** {premium_status}\n"
            f"ЁЯУИ **Total Interactions:** {user_data.get('total_interactions', 0)}\n"
            f"ЁЯОп **Commands Used:** {user_data.get('total_interactions', 0)}\n" # This might be total interactions, refine if needed
            f"ЁЯУЕ **First Seen:** {first_seen}\n"
            f"тП░ **Last Active:** {last_active}\n\n"
            "ЁЯТб **Want better stats? Get premium for detailed analytics!**"
        )

        markup = InlineKeyboardMarkup([
            [InlineKeyboardButton("ЁЯТО Get Premium", callback_data='get_premium')],
            [InlineKeyboardButton("ЁЯУИ Group Stats", callback_data='group_stats_help')]
        ])

        await message.reply_text(stats_text, reply_markup=markup, parse_mode=ParseMode.MARKDOWN)

    @app.on_message(filters.command("connect")) # Moved from start.py
    async def connect_group(client, message: Message):
        """Connect group to the bot or show connection status."""
        if message.chat.type == "private":
            connect_text = (
                "ЁЯФЧ **Connect Your Group to As ki Angel Bot**\n\n"
                "**How to connect your group:**\n"
                "1. Add me to your group as admin\n"
                "2. Use `/connect` command in the group\n"
                "3. I'll start learning from conversations!\n\n"
                "**Benefits of connecting:**\n"
                "тАв ЁЯза Personalized responses for your group\n"
                "тАв ЁЯУК Group analytics and insights\n"
                "тАв ЁЯОн Unique personality development\n"
                "тАв ЁЯФТ Privacy-focused learning\n\n"
                "**Need help?** Join our support group!"
            )

            bot_username = (await client.get_me()).username
            markup = InlineKeyboardMarkup([
                [InlineKeyboardButton("тЮХ Add Me to Group", url=f"https://t.me/{bot_username}?startgroup=true")],
                [InlineKeyboardButton("ЁЯПв Support Group", url=OFFICIAL_GROUP_LINK)]
            ])

            await message.reply_text(connect_text, reply_markup=markup, parse_mode=ParseMode.MARKDOWN)
            return

        # If command is used in group
        chat_id = message.chat.id
        chat_title = message.chat.title

        # Save/update group data with timestamp using db._run_in_executor
        connected_at_str = time.strftime('%d %b %Y', time.localtime()) # Store as formatted string
        await db._run_in_executor(
            db.connected_groups.update_one,
            {'_id': chat_id},
            {
                '$set': {
                    'chat_title': chat_title,
                    'connected_at': connected_at_str,
                    'last_updated': time.time(),
                    'status': 'active'
                }
            },
            upsert=True
        )

        # Get group stats
        group_data = await db.get_group_learning_data(chat_id) # This call handles default creation if not exists
        learned_phrases_count = len(group_data.get('phrases', []))
        learned_stickers_count = len(group_data.get('stickers', []))

        connect_text = (
            f"тЬЕ **Group Connected Successfully!**\n\n"
            f"ЁЯПв **Group:** {chat_title}\n"
            f"ЁЯЖФ **Chat ID:** `{chat_id}`\n"
            f"ЁЯСе **Members:** {await client.get_chat_members_count(chat_id)}\n"
            f"ЁЯза **Learned Messages:** {learned_phrases_count}\n"
            f"ЁЯОн **Learned Stickers:** {learned_stickers_count}\n\n"
            "ЁЯОп **I'm now learning from this group's conversations!**\n"
            "Use `/learn_stats` to see detailed learning progress."
        )

        markup = InlineKeyboardMarkup([
            [InlineKeyboardButton("ЁЯУК Group Stats", callback_data='learn_stats')],
            [InlineKeyboardButton("ЁЯТО Get Premium", callback_data='get_premium')]
        ])

        await message.reply_text(connect_text, reply_markup=markup, parse_mode=ParseMode.MARKDOWN)

    @app.on_message(filters.command("group_info") & filters.group) # Moved from learning.py
    async def group_info_command(client, message: Message):
        """Show group information and bot status."""
        chat_id = message.chat.id
        chat = message.chat
        user_id = message.from_user.id

        # Check if user is admin
        try:
            member = await client.get_chat_member(chat_id, user_id)
            if member.status not in ['administrator', 'creator']:
                await message.reply_text("тЫФ Only admins can use this command!")
                return
        except Exception as e:
            await message.reply_text(f"тЭМ Unable to verify admin status: {e}")
            return

        # Get group data
        try:
            group_data = await db._run_in_executor(db.connected_groups.find_one, {'_id': chat_id}) or {}
            learning_data = await db.get_group_learning_data(chat_id)
        except Exception as e:
            await message.reply_text(f"тЭМ Error getting group data: {e}")
            return

        # Calculate learning stats
        learned_phrases_count = len(learning_data.get('phrases', []))
        learned_stickers_count = len(learning_data.get('stickers', []))
        response_patterns_count = len(learning_data.get('response_patterns', {}))

        # Get member count
        try:
            member_count = await client.get_chat_members_count(chat_id)
        except Exception as e:
            member_count = "Unknown"
            print(f"Error getting member count for {chat_id}: {e}")

        info_text = (
            f"ЁЯУЛ **Group Information**\n\n"
            f"ЁЯП╖я╕П **Name:** {chat.title}\n"
            f"ЁЯЖФ **Chat ID:** `{chat_id}`\n"
            f"ЁЯСе **Members:** {member_count}\n"
            f"ЁЯдЦ **Bot Status:** {'тЬЕ Active' if group_data else 'тЭМ Not Connected'}\n"
            f"ЁЯза **Learning Status:** {'тЬЕ Enabled' if group_data.get('learning_enabled', True) else 'тЭМ Disabled'}\n\n"
            f"ЁЯУК **Learning Progress:**\n"
            f"тАв Messages Learned: {learned_phrases_count}\n"
            f"тАв Stickers Learned: {learned_stickers_count}\n"
            f"тАв Response Patterns: {response_patterns_count}\n"
            f"тАв Connected Since: {group_data.get('connected_at', 'Unknown')}\n\n"
            "ЁЯТб **Available Commands:**\n"
            "тАв `/learn_stats` - Detailed learning statistics\n"
            "тАв `/reset_learning` - Reset learning data\n"
            "тАв `/connect` - Reconnect the bot"
        )

        markup = InlineKeyboardMarkup([
            [InlineKeyboardButton("ЁЯУК Learning Stats", callback_data='learn_stats')],
            [InlineKeyboardButton("ЁЯТО Premium Features", callback_data='get_premium')]
        ])

        await message.reply_text(info_text, reply_markup=markup, parse_mode=ParseMode.MARKDOWN)
